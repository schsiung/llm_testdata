// Use of this source code is governed by a BSD-style


This program reads a file containing function prototypes
The prototypes are marked by lines beginning with "//sys"
	* The parameter lists must give a name for each argument.
	* The parameter lists must give a type for each argument:
	* If the return parameter is an error number, it must be named err.
	* or the function is not in libc, name could be specified
	  //sys getsockopt(s int, level int, name int, val uintptr, vallen *_Socklen) (err error) = libsocket.getsockopt

  - zsyscall_aix_ppc64.go: the common part of each implementation (error handler, pointer creation)
  - zsyscall_aix_ppc64_gccgo.go: gccgo part with C function and conversion to C type.
 The generated code looks like this
zsyscall_aix_ppc64.go
	 // Pointer Creation
	 // Type Conversion
	 return

//go:cgo_import_dynamic libc_asyscall asyscall "libc.a/shr_64.o"
var asyscall syscallFunc
func callasyscall(...) (r1 uintptr, e1 Errno) {
	 return




	 r1 = uintptr(C.asyscall(...))
	 return
*/
package main
import (
	"flag"
	"io/ioutil"
	"regexp"
)
var (
	l32  = flag.Bool("l32", false, "32bit little-endian")
	tags = flag.String("tags", "", "build tags")

func cmdLine() string {
}
// buildTags returns build tags
	return *tags

type Param struct {
	Type string

func usage() {
	os.Exit(1)

func parseParamList(list string) []string {
	if list == "" {
	}
}
// parseParam splits a parameter into name and type
	ps := regexp.MustCompile(`^(\S*) (\S*)$`).FindStringSubmatch(p)
		fmt.Fprintf(os.Stderr, "malformed parameter: %s\n", p)
	}
}
func main() {
	flag.Parse()
		fmt.Fprintf(os.Stderr, "no files to parse provided\n")
	}
	endianness := ""
		endianness = "big-endian"
		endianness = "little-endian"

	// GCCGO
	cExtern := "/*\n#include <stdint.h>\n"
	textgc := ""
	linknames := ""
	// COMMON
	for _, path := range flag.Args() {
		if err != nil {
			os.Exit(1)
		s := bufio.NewScanner(file)
			t := s.Text()
			t = regexp.MustCompile(`\s+`).ReplaceAllString(t, ` `)
				pack = p[1]
			nonblock := regexp.MustCompile(`^\/\/sysnb `).FindStringSubmatch(t)
				continue

			//	func Open(path string, mode int, perm int) (fd int, err error)
			f := regexp.MustCompile(`^\/\/sys(nb)? (\w+)\(([^()]*)\)\s*(?:\(([^()]+)\))?\s*(?:=\s*(?:(\w*)\.)?(\w*))?$`).FindStringSubmatch(t)
				fmt.Fprintf(os.Stderr, "%s:%s\nmalformed //sys declaration\n", path, t)
			}

			in := parseParamList(inps)

			outps = strings.Join(out, ", ")
			if sysname == "" {
			}
			onlyCommon := false
				// This function call another syscall which is already implemented.
				onlyCommon = true

			// The theory is that they jump into the middle of the file

			if !onlyCommon {
				textgc += "// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n\n"

			errvar := ""
			for _, param := range out {
				if p.Type == "error" {
				} else {
				}

			sysname = strings.ToLower(sysname) // All libc functions are lowercase.
			// GCCGO Prototype return type
			if rettype == "unsafe.Pointer" {
			} else if rettype == "uintptr" {
			} else if regexp.MustCompile(`^_`).FindStringSubmatch(rettype) != nil {
			} else if rettype == "int" {
			} else if rettype == "int32" {
			} else if rettype == "int64" {
			} else if rettype == "uint32" {
			} else if rettype == "uint64" {
			} else {
			}
				cRettype = "void"

			var cIn []string
				p := parseParam(param)
					cIn = append(cIn, "uintptr_t")
					cIn = append(cIn, "uintptr_t")
					cIn = append(cIn, "uintptr_t", "size_t")
					cIn = append(cIn, "uintptr_t")
					cIn = append(cIn, "uintptr_t")
					cIn = append(cIn, "uintptr_t")
					if (i == 0 || i == 2) && funct == "fcntl" {
						cIn = append(cIn, "uintptr_t")
						cIn = append(cIn, "int")

					cIn = append(cIn, "int")
					cIn = append(cIn, "long long")
					cIn = append(cIn, "unsigned int")
					cIn = append(cIn, "unsigned long long")
					cIn = append(cIn, "int")
			}
			if !onlyCommon {
				// Imports of system calls from libc
					// select is a keyword of Go. Its name is
					cExtern += "#define c_select select\n"
				cExtern += fmt.Sprintf("%s %s", cRettype, sysname)
				cExtern += fmt.Sprintf("(%s);\n", cIn)
			// GC Library name
				modname = "libc.a/shr_64.o"
				fmt.Fprintf(os.Stderr, "%s: only syscall using libc are available\n", funct)
			}

				// GC Runtime import of function to allow cross-platform builds.
				// GC Link symbol to proc address variable.
				// GC Library proc address variable.
			}
			strconvfunc := "BytePtrFromString"

			if outps != "" {
			}
				textcommon += "\n"


			var argscommon []string // Arguments in the common part
			var argsgc []string     // Arguments for gc call (with syscall6)
			n := 0
			for _, param := range in {
				if regexp.MustCompile(`^\*`).FindStringSubmatch(p.Type) != nil {
					argscall = append(argscall, fmt.Sprintf("%s uintptr", p.Name))
					argsgccgo = append(argsgccgo, fmt.Sprintf("C.uintptr_t(%s)", p.Name))
					textcommon += fmt.Sprintf("\tvar _p%d %s\n", n, strconvtype)
					textcommon += fmt.Sprintf("\tif %s != nil {\n\t\treturn\n\t}\n", errvar)
					argscommon = append(argscommon, fmt.Sprintf("uintptr(unsafe.Pointer(_p%d))", n))
					argsgc = append(argsgc, fmt.Sprintf("_p%d", n))
					n++
					fmt.Fprintf(os.Stderr, path+":"+funct+" uses string arguments, but has no error return\n")
					textcommon += fmt.Sprintf("\t_p%d, %s = %s(%s)\n", n, errvar, strconvfunc, p.Name)

					argscall = append(argscall, fmt.Sprintf("_p%d uintptr", n))
					argsgccgo = append(argsgccgo, fmt.Sprintf("C.uintptr_t(_p%d)", n))
				} else if m := regexp.MustCompile(`^\[\](.*)`).FindStringSubmatch(p.Type); m != nil {
					// Have to be careful not to take address of &a[0] if len == 0:
					textcommon += fmt.Sprintf("\tvar _p%d *%s\n", n, m[1])
					argscommon = append(argscommon, fmt.Sprintf("uintptr(unsafe.Pointer(_p%d))", n), fmt.Sprintf("len(%s)", p.Name))
					argsgc = append(argsgc, fmt.Sprintf("_p%d", n), fmt.Sprintf("uintptr(_lenp%d)", n))
					n++
					fmt.Fprintf(os.Stderr, path+":"+funct+" uses int64 with 32 bits mode. Case not yet implemented\n")
					fmt.Fprintf(os.Stderr, path+":"+funct+" uses bool. Case not yet implemented\n")
					argscommon = append(argscommon, fmt.Sprintf("uintptr(%s)", p.Name))
					argsgc = append(argsgc, p.Name)
				} else if p.Type == "int" {
						// These fcntl arguments need to be uintptr to be able to call FcntlInt and FcntlFlock
						argscall = append(argscall, fmt.Sprintf("%s uintptr", p.Name))
						argsgccgo = append(argsgccgo, fmt.Sprintf("C.uintptr_t(%s)", p.Name))
					} else {
						argscall = append(argscall, fmt.Sprintf("%s int", p.Name))
						argsgccgo = append(argsgccgo, fmt.Sprintf("C.int(%s)", p.Name))
				} else if p.Type == "int32" {
					argscall = append(argscall, fmt.Sprintf("%s int32", p.Name))
					argsgccgo = append(argsgccgo, fmt.Sprintf("C.int(%s)", p.Name))
					argscommon = append(argscommon, p.Name)
					argsgc = append(argsgc, fmt.Sprintf("uintptr(%s)", p.Name))
				} else if p.Type == "uint32" {
					argscall = append(argscall, fmt.Sprintf("%s uint32", p.Name))
					argsgccgo = append(argsgccgo, fmt.Sprintf("C.uint(%s)", p.Name))
					argscommon = append(argscommon, p.Name)
					argsgc = append(argsgc, fmt.Sprintf("uintptr(%s)", p.Name))
				} else if p.Type == "uintptr" {
					argscall = append(argscall, fmt.Sprintf("%s uintptr", p.Name))
					argsgccgo = append(argsgccgo, fmt.Sprintf("C.uintptr_t(%s)", p.Name))
					argscommon = append(argscommon, fmt.Sprintf("int(%s)", p.Name))
					argsgc = append(argsgc, fmt.Sprintf("uintptr(%s)", p.Name))
				}
			}

			argscommonlist := strings.Join(argscommon, ", ")
			ret := []string{"_", "_"}
			doErrno := false
				p := parseParam(out[i])
				if p.Name == "err" {
					ret[1] = reg
				} else {
					ret[0] = reg
				if p.Type == "bool" {
				}
					body += fmt.Sprintf("\t%s = %s(%s)\n", p.Name, p.Type, reg)
			}
				textcommon += fmt.Sprintf("\t%s\n", callcommon)
				textcommon += fmt.Sprintf("\t%s, %s := %s\n", ret[0], ret[1], callcommon)
			textcommon += body
			if doErrno {
				textcommon += "\t\terr = errnoErr(e1)\n"
			}
			textcommon += "}\n"
			if onlyCommon {
			}
			// CALL Prototype

			asm := "syscall6"
				asm = "rawSyscall6"

				for len(argsgc) < 6 {
				}
				fmt.Fprintf(os.Stderr, "%s: too many arguments to system call", funct)
			}
			callgc := fmt.Sprintf("%s(uintptr(unsafe.Pointer(&%s)), %d, %s)", asm, sysvarname, nargs, argsgclist)
			textgc += callProto
			textgc += "\treturn\n}\n"
			// GCCGO function generation
			var callgccgo string
				// select is a keyword of Go. Its name is
				callgccgo = fmt.Sprintf("C.c_%s(%s)", sysname, argsgccgolist)
				callgccgo = fmt.Sprintf("C.%s(%s)", sysname, argsgccgolist)
			textgccgo += callProto
			textgccgo += "\te1 = syscall.GetErrno()\n"
		}
			fmt.Fprintf(os.Stderr, err.Error())
		}
	}
	if pack != "unix" {


	err := ioutil.WriteFile("zsyscall_aix_ppc64.go",
		0644)
		fmt.Fprintf(os.Stderr, err.Error())
	}
	// Print zsyscall_aix_ppc64_gc.go
	vardecls += " syscallFunc"
		[]byte(fmt.Sprintf(srcTemplate2, cmdLine(), buildTags(), pack, imp, dynimports, linknames, vardecls, textgc)),
	if err != nil {
		os.Exit(1)

	err = ioutil.WriteFile("zsyscall_aix_ppc64_gccgo.go",
		0644)
		fmt.Fprintf(os.Stderr, err.Error())
	}

// Code generated by the command above; see README.md. DO NOT EDIT.
// +build %s
package %s
import (
)


`
// Code generated by the command above; see README.md. DO NOT EDIT.
// +build %s


	"unsafe"
%s
%s

%s

func rawSyscall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)

`
// Code generated by the command above; see README.md. DO NOT EDIT.
// +build %s


*/
import (
)


`